<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Rodbus-FFI: include/rodbus/rodbus.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Rodbus-FFI
   &#160;<span id="projectnumber">0.1.1</span>
   </div>
   <div id="projectbrief">Idiomatic C API to the Rodbus crate via Rust FFI</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_03373372691da3bd91b4f59857e090bd.html">rodbus</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rodbus.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdarg.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &quot;<a class="el" href="prelude_8h_source.html">prelude.h</a>&quot;</code><br />
</div>
<p><a href="rodbus_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_session.html">Session</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct that bundles together the types needed to make requests on a channel.  <a href="struct_session.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_callbacks.html">Callbacks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sizes.html">Sizes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_runtime_config.html">RuntimeConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional non-default configuration of the Tokio runtime.  <a href="struct_runtime_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_result.html">Result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type that describes the success or failure of an operation.  <a href="struct_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a33cd4def3f49e5c51e0c17184e3f4f2c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#a33cd4def3f49e5c51e0c17184e3f4f2c">MAX_READ_COILS_COUNT</a>&#160;&#160;&#160;2000</td></tr>
<tr class="separator:a33cd4def3f49e5c51e0c17184e3f4f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6716f776ec018d9e18ba0d28ae104ac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#af6716f776ec018d9e18ba0d28ae104ac">MAX_READ_REGISTERS_COUNT</a>&#160;&#160;&#160;125</td></tr>
<tr class="separator:af6716f776ec018d9e18ba0d28ae104ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7bc9595980455fd0d58359d8cd97fb3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#ae7bc9595980455fd0d58359d8cd97fb3">MAX_WRITE_COILS_COUNT</a>&#160;&#160;&#160;1968</td></tr>
<tr class="separator:ae7bc9595980455fd0d58359d8cd97fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5512749e704891158f2941eb0ecf1b1e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#a5512749e704891158f2941eb0ecf1b1e">MAX_WRITE_REGISTERS_COUNT</a>&#160;&#160;&#160;123</td></tr>
<tr class="separator:a5512749e704891158f2941eb0ecf1b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:adac335ec9f22fdaa8e18ca2d8130d90a"><td class="memItemLeft" align="right" valign="top">typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#adac335ec9f22fdaa8e18ca2d8130d90a">Exception</a></td></tr>
<tr class="separator:adac335ec9f22fdaa8e18ca2d8130d90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108f283de9b3b197e8cf1f6b2646c12c"><td class="memItemLeft" align="right" valign="top">typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#a108f283de9b3b197e8cf1f6b2646c12c">Level</a></td></tr>
<tr class="separator:a108f283de9b3b197e8cf1f6b2646c12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f792ad9fd33e21293f4305ac9951cb"><td class="memItemLeft" align="right" valign="top">typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#af4f792ad9fd33e21293f4305ac9951cb">Status</a></td></tr>
<tr class="separator:af4f792ad9fd33e21293f4305ac9951cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53c4c86b8df187b3535456771fa8681"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="rodbus_8h.html#ab53c4c86b8df187b3535456771fa8681">BitIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#ab53c4c86b8df187b3535456771fa8681">BitIterator</a></td></tr>
<tr class="separator:ab53c4c86b8df187b3535456771fa8681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7f3245e13691d73f52c0b7caf580f3"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="rodbus_8h.html#a7e7f3245e13691d73f52c0b7caf580f3">Handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#a7e7f3245e13691d73f52c0b7caf580f3">Handler</a></td></tr>
<tr class="separator:a7e7f3245e13691d73f52c0b7caf580f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1479d7a4be4e0a3ed7c0656724dc1dd0"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="rodbus_8h.html#a1479d7a4be4e0a3ed7c0656724dc1dd0">RegisterIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#a1479d7a4be4e0a3ed7c0656724dc1dd0">RegisterIterator</a></td></tr>
<tr class="separator:a1479d7a4be4e0a3ed7c0656724dc1dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4d68429aebf64b1a0686d32a333787"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="rodbus_8h.html#a2a4d68429aebf64b1a0686d32a333787">ServerHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#a2a4d68429aebf64b1a0686d32a333787">ServerHandle</a></td></tr>
<tr class="separator:a2a4d68429aebf64b1a0686d32a333787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993c841f36546f091efb45eb10bdeb65"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="rodbus_8h.html#a993c841f36546f091efb45eb10bdeb65">Updater</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#a993c841f36546f091efb45eb10bdeb65">Updater</a></td></tr>
<tr class="separator:a993c841f36546f091efb45eb10bdeb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1b89c3102156804ef750df9ac42d97"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_session.html">Session</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#a8f1b89c3102156804ef750df9ac42d97">Session</a></td></tr>
<tr class="memdesc:a8f1b89c3102156804ef750df9ac42d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct that bundles together the types needed to make requests on a channel.  <a href="#a8f1b89c3102156804ef750df9ac42d97">More...</a><br /></td></tr>
<tr class="separator:a8f1b89c3102156804ef750df9ac42d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad039b46d64231cd22a98d29d400cef6c"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#ad039b46d64231cd22a98d29d400cef6c">WriteSingleCallback_bool</a>) (bool, uint16_t, void *)</td></tr>
<tr class="separator:ad039b46d64231cd22a98d29d400cef6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75ccc37e5e9e41478938d3391afe192"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#aa75ccc37e5e9e41478938d3391afe192">WriteSingleCallback_u16</a>) (uint16_t, uint16_t, void *)</td></tr>
<tr class="separator:aa75ccc37e5e9e41478938d3391afe192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f667aaa4f41c199aa8f5d54fa7abbdc"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#a2f667aaa4f41c199aa8f5d54fa7abbdc">WriteMultipleCallback_bool</a>) (const bool *, uint16_t, uint16_t, void *)</td></tr>
<tr class="separator:a2f667aaa4f41c199aa8f5d54fa7abbdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb591b5372fb9faaab1a4648568fcdb0"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#acb591b5372fb9faaab1a4648568fcdb0">WriteMultipleCallback_u16</a>) (const uint16_t *, uint16_t, uint16_t, void *)</td></tr>
<tr class="separator:acb591b5372fb9faaab1a4648568fcdb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6776934484c8b4f38d405e630af94738"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_callbacks.html">Callbacks</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#a6776934484c8b4f38d405e630af94738">Callbacks</a></td></tr>
<tr class="separator:a6776934484c8b4f38d405e630af94738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc210d6f5ce14c41ad562ef100ac3532"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_sizes.html">Sizes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#afc210d6f5ce14c41ad562ef100ac3532">Sizes</a></td></tr>
<tr class="separator:afc210d6f5ce14c41ad562ef100ac3532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313c85f25e6379ee8b06fd7af42e5f26"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_runtime_config.html">RuntimeConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#a313c85f25e6379ee8b06fd7af42e5f26">RuntimeConfig</a></td></tr>
<tr class="memdesc:a313c85f25e6379ee8b06fd7af42e5f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional non-default configuration of the Tokio runtime.  <a href="#a313c85f25e6379ee8b06fd7af42e5f26">More...</a><br /></td></tr>
<tr class="separator:a313c85f25e6379ee8b06fd7af42e5f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49525aea41578e35d3e8fa40032fff9"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#ae49525aea41578e35d3e8fa40032fff9">Result</a></td></tr>
<tr class="memdesc:ae49525aea41578e35d3e8fa40032fff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type that describes the success or failure of an operation.  <a href="#ae49525aea41578e35d3e8fa40032fff9">More...</a><br /></td></tr>
<tr class="separator:ae49525aea41578e35d3e8fa40032fff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a8852f03cd91327c7c725673317d85b46"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#a8852f03cd91327c7c725673317d85b46">Exception</a> { <br />
&#160;&#160;<a class="el" href="rodbus_8h.html#a8852f03cd91327c7c725673317d85b46a8a4915a2a34c1ab34d038ea97fa7b709">EXCEPTION_ILLEGAL_FUNCTION</a> = 1, 
<a class="el" href="rodbus_8h.html#a8852f03cd91327c7c725673317d85b46a7b0b398e7376a97021809dee5787fe8d">EXCEPTION_ILLEGAL_DATA_ADDRESS</a> = 2, 
<a class="el" href="rodbus_8h.html#a8852f03cd91327c7c725673317d85b46a5ebe78681cfc53531dc576e386ea99c6">EXCEPTION_ILLEGAL_DATA_VALUE</a> = 3, 
<a class="el" href="rodbus_8h.html#a8852f03cd91327c7c725673317d85b46a99262768ea68576a7393e449a85877a5">EXCEPTION_SERVER_DEVICE_FAILURE</a> = 4, 
<br />
&#160;&#160;<a class="el" href="rodbus_8h.html#a8852f03cd91327c7c725673317d85b46a4615b0ea86a36267ae531f78a6b052de">EXCEPTION_ACKNOWLEDGE</a> = 5, 
<a class="el" href="rodbus_8h.html#a8852f03cd91327c7c725673317d85b46ad796a97a298b53b63908bde5180b695a">EXCEPTION_SERVER_DEVICE_BUSY</a> = 6, 
<a class="el" href="rodbus_8h.html#a8852f03cd91327c7c725673317d85b46ac5ebf2927bd32cc02fdfc59dbc8b6933">EXCEPTION_MEMORY_PARITY_ERROR</a> = 8, 
<a class="el" href="rodbus_8h.html#a8852f03cd91327c7c725673317d85b46aed20382ced082cb1dcdcc845f1e82f10">EXCEPTION_GATEWAY_PATH_UNAVAILABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="rodbus_8h.html#a8852f03cd91327c7c725673317d85b46a7e683d36801355c4979556ac0c1b856f">EXCEPTION_GATEWAY_TARGET_DEVICE_FAILED_TO_RESPOND</a> = 11
<br />
 }</td></tr>
<tr class="separator:a8852f03cd91327c7c725673317d85b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221b779e6bb7b8d40677d7642bfefac5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#a221b779e6bb7b8d40677d7642bfefac5">Level</a> { <br />
&#160;&#160;<a class="el" href="rodbus_8h.html#a221b779e6bb7b8d40677d7642bfefac5a56f6226774ca281a80cd2ee0ddd84f8b">LEVEL_ERROR</a>, 
<a class="el" href="rodbus_8h.html#a221b779e6bb7b8d40677d7642bfefac5af1af3c11f22a52b3c8e7b2472275181f">LEVEL_WARN</a>, 
<a class="el" href="rodbus_8h.html#a221b779e6bb7b8d40677d7642bfefac5a831e8f5cdb3ed97330b2e17502149d8f">LEVEL_INFO</a>, 
<a class="el" href="rodbus_8h.html#a221b779e6bb7b8d40677d7642bfefac5a210bac66f34a56114215d54588b8c7f3">LEVEL_DEBUG</a>, 
<br />
&#160;&#160;<a class="el" href="rodbus_8h.html#a221b779e6bb7b8d40677d7642bfefac5a1ca076c143f2ec60ba02c86573af9da3">LEVEL_TRACE</a>
<br />
 }</td></tr>
<tr class="separator:a221b779e6bb7b8d40677d7642bfefac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a0db04d321a74b7e7fcfd3f1a3f70b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#a67a0db04d321a74b7e7fcfd3f1a3f70b">Status</a> { <br />
&#160;&#160;<a class="el" href="rodbus_8h.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba7e4a42e3b6dd63708c64cf3db6f69566">STATUS_OK</a>, 
<a class="el" href="rodbus_8h.html#a67a0db04d321a74b7e7fcfd3f1a3f70bafe3be2ba8f0a700faab0406f0343865b">STATUS_SHUTDOWN</a>, 
<a class="el" href="rodbus_8h.html#a67a0db04d321a74b7e7fcfd3f1a3f70bab08ccce70f99d316ca27d1b008d42226">STATUS_NO_CONNECTION</a>, 
<a class="el" href="rodbus_8h.html#a67a0db04d321a74b7e7fcfd3f1a3f70badf018f95e71f6974db3f5c46ca93cb23">STATUS_RESPONSE_TIMEOUT</a>, 
<br />
&#160;&#160;<a class="el" href="rodbus_8h.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba43c6fc585ae12703b11c0bc9ea7c0f2b">STATUS_BAD_REQUEST</a>, 
<a class="el" href="rodbus_8h.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba4b03b4e872682fcc47146c62e0f4d4ee">STATUS_BAD_RESPONSE</a>, 
<a class="el" href="rodbus_8h.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba6373919fa18245967d76144389ca22fd">STATUS_IO_ERROR</a>, 
<a class="el" href="rodbus_8h.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba00923b9e21c66ab1958fd8ebcbc56d86">STATUS_BAD_FRAMING</a>, 
<br />
&#160;&#160;<a class="el" href="rodbus_8h.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba376a5fd798c7c418fdf4a664e648f984">STATUS_EXCEPTION</a>, 
<a class="el" href="rodbus_8h.html#a67a0db04d321a74b7e7fcfd3f1a3f70badbee399e52770145a726e8bf2a7d6c83">STATUS_INTERNAL_ERROR</a>
<br />
 }</td></tr>
<tr class="separator:a67a0db04d321a74b7e7fcfd3f1a3f70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2bacd8d546939e77079400e4b4785ae4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rodbus_8h.html#a993c841f36546f091efb45eb10bdeb65">Updater</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#a2bacd8d546939e77079400e4b4785ae4">acquire_updater</a> (<a class="el" href="rodbus_8h.html#a7e7f3245e13691d73f52c0b7caf580f3">Handler</a> *handler)</td></tr>
<tr class="separator:a2bacd8d546939e77079400e4b4785ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b2c41bbed5f0474ec818be8c207e60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_session.html">Session</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#a12b2c41bbed5f0474ec818be8c207e60">build_session</a> (<a class="el" href="prelude_8h.html#a26be402b6358a7159963c58bfcd5819f">Runtime</a> *runtime, <a class="el" href="prelude_8h.html#afba562878a3535479ef88914e89ee38b">Channel</a> *channel, uint8_t unit_id, uint32_t timeout_ms)</td></tr>
<tr class="memdesc:a12b2c41bbed5f0474ec818be8c207e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to build a session struct.  <a href="#a12b2c41bbed5f0474ec818be8c207e60">More...</a><br /></td></tr>
<tr class="separator:a12b2c41bbed5f0474ec818be8c207e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5bf17a00e67b15e844462febb25065"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_callbacks.html">Callbacks</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#a4c5bf17a00e67b15e844462febb25065">create_callbacks</a> (<a class="el" href="rodbus_8h.html#ad039b46d64231cd22a98d29d400cef6c">WriteSingleCallback_bool</a> <a class="el" href="rodbus_8h.html#a327ccccc822f94fa942bb7ef3d78f042">write_single_coil_cb</a>, <a class="el" href="rodbus_8h.html#aa75ccc37e5e9e41478938d3391afe192">WriteSingleCallback_u16</a> <a class="el" href="rodbus_8h.html#a4259f83622e0fda71a38d834126cfe16">write_single_register_cb</a>, <a class="el" href="rodbus_8h.html#a2f667aaa4f41c199aa8f5d54fa7abbdc">WriteMultipleCallback_bool</a> <a class="el" href="rodbus_8h.html#a04c2d33bb4ff5d66ec8b0337a8260818">write_multiple_coils</a>, <a class="el" href="rodbus_8h.html#acb591b5372fb9faaab1a4648568fcdb0">WriteMultipleCallback_u16</a> <a class="el" href="rodbus_8h.html#a37e8cfee194af77cd6c43257feb5ed5a">write_multiple_registers</a>)</td></tr>
<tr class="separator:a4c5bf17a00e67b15e844462febb25065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591e5e747665b5920f2479ff7f6af910"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rodbus_8h.html#a7e7f3245e13691d73f52c0b7caf580f3">Handler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#a591e5e747665b5920f2479ff7f6af910">create_handler</a> (<a class="el" href="prelude_8h.html#a26be402b6358a7159963c58bfcd5819f">Runtime</a> *runtime, <a class="el" href="struct_sizes.html">Sizes</a> sizes, <a class="el" href="struct_callbacks.html">Callbacks</a> callbacks, void *user_data)</td></tr>
<tr class="separator:a591e5e747665b5920f2479ff7f6af910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9f8ed2895405a6a928d19056bf4561"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rodbus_8h.html#a2a4d68429aebf64b1a0686d32a333787">ServerHandle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#aea9f8ed2895405a6a928d19056bf4561">create_server</a> (<a class="el" href="prelude_8h.html#a26be402b6358a7159963c58bfcd5819f">Runtime</a> *runtime, const char *address, uint8_t unit_id, <a class="el" href="rodbus_8h.html#a7e7f3245e13691d73f52c0b7caf580f3">Handler</a> *handler)</td></tr>
<tr class="separator:aea9f8ed2895405a6a928d19056bf4561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0265406efea9cf22a481b867bcec06f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_sizes.html">Sizes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#a0265406efea9cf22a481b867bcec06f0">create_sizes</a> (uint16_t num_coils, uint16_t num_discrete_inputs, uint16_t num_holding_registers, uint16_t num_input_registers)</td></tr>
<tr class="separator:a0265406efea9cf22a481b867bcec06f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb2c7bb90fd97a74cfd6d0572d3c3ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="prelude_8h.html#afba562878a3535479ef88914e89ee38b">Channel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#abcb2c7bb90fd97a74cfd6d0572d3c3ec">create_tcp_client</a> (<a class="el" href="prelude_8h.html#a26be402b6358a7159963c58bfcd5819f">Runtime</a> *runtime, const char *address, uint16_t max_queued_requests)</td></tr>
<tr class="memdesc:abcb2c7bb90fd97a74cfd6d0572d3c3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an instance of a TCP client channel.  <a href="#abcb2c7bb90fd97a74cfd6d0572d3c3ec">More...</a><br /></td></tr>
<tr class="separator:abcb2c7bb90fd97a74cfd6d0572d3c3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5410132a1670efd88528088d9365952a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="prelude_8h.html#a26be402b6358a7159963c58bfcd5819f">Runtime</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#a5410132a1670efd88528088d9365952a">create_threaded_runtime</a> (const <a class="el" href="struct_runtime_config.html">RuntimeConfig</a> *config)</td></tr>
<tr class="memdesc:a5410132a1670efd88528088d9365952a"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an instance of the multi-threaded work-stealing Tokio runtime  <a href="#a5410132a1670efd88528088d9365952a">More...</a><br /></td></tr>
<tr class="separator:a5410132a1670efd88528088d9365952a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ca2d2f2ed0ab11963dc54730105a7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#ad3ca2d2f2ed0ab11963dc54730105a7b">destroy_channel</a> (<a class="el" href="prelude_8h.html#afba562878a3535479ef88914e89ee38b">Channel</a> *channel)</td></tr>
<tr class="memdesc:ad3ca2d2f2ed0ab11963dc54730105a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a previously created channel instance.  <a href="#ad3ca2d2f2ed0ab11963dc54730105a7b">More...</a><br /></td></tr>
<tr class="separator:ad3ca2d2f2ed0ab11963dc54730105a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200473b8beed8a70ff55a18b902834f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#a200473b8beed8a70ff55a18b902834f0">destroy_handler</a> (<a class="el" href="rodbus_8h.html#a7e7f3245e13691d73f52c0b7caf580f3">Handler</a> *handler)</td></tr>
<tr class="separator:a200473b8beed8a70ff55a18b902834f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9b66ac23c961204362dbe48598f7b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#ace9b66ac23c961204362dbe48598f7b4">destroy_runtime</a> (<a class="el" href="prelude_8h.html#a26be402b6358a7159963c58bfcd5819f">Runtime</a> *runtime)</td></tr>
<tr class="memdesc:ace9b66ac23c961204362dbe48598f7b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a previously created runtime instance.  <a href="#ace9b66ac23c961204362dbe48598f7b4">More...</a><br /></td></tr>
<tr class="separator:ace9b66ac23c961204362dbe48598f7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33724585794192d9866c988a1ea5835"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#ad33724585794192d9866c988a1ea5835">destroy_server</a> (<a class="el" href="rodbus_8h.html#a2a4d68429aebf64b1a0686d32a333787">ServerHandle</a> *handle)</td></tr>
<tr class="separator:ad33724585794192d9866c988a1ea5835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89467479f2356b5694d5294ea68ccdcf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#a89467479f2356b5694d5294ea68ccdcf">get_next_bit</a> (<a class="el" href="rodbus_8h.html#ab53c4c86b8df187b3535456771fa8681">BitIterator</a> *iterator, bool *value, uint16_t *index)</td></tr>
<tr class="memdesc:a89467479f2356b5694d5294ea68ccdcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieve the next bit and/or index from iterator  <a href="#a89467479f2356b5694d5294ea68ccdcf">More...</a><br /></td></tr>
<tr class="separator:a89467479f2356b5694d5294ea68ccdcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcbc9b6b65ddad049cd64b4b7ec96a2f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#abcbc9b6b65ddad049cd64b4b7ec96a2f">get_next_register</a> (<a class="el" href="rodbus_8h.html#a1479d7a4be4e0a3ed7c0656724dc1dd0">RegisterIterator</a> *iterator, uint16_t *value, uint16_t *index)</td></tr>
<tr class="memdesc:abcbc9b6b65ddad049cd64b4b7ec96a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieve the next register value and/or index from iterator  <a href="#abcbc9b6b65ddad049cd64b4b7ec96a2f">More...</a><br /></td></tr>
<tr class="separator:abcbc9b6b65ddad049cd64b4b7ec96a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85931f5288323e2dce1f7bf7c73b459"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#ab85931f5288323e2dce1f7bf7c73b459">read_coils</a> (<a class="el" href="struct_session.html">Session</a> *session, uint16_t start, uint16_t count, bool *output)</td></tr>
<tr class="memdesc:ab85931f5288323e2dce1f7bf7c73b459"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform a blocking operation to read coils  <a href="#ab85931f5288323e2dce1f7bf7c73b459">More...</a><br /></td></tr>
<tr class="separator:ab85931f5288323e2dce1f7bf7c73b459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd307d999611d65b5f2686497d6eae8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#a9cd307d999611d65b5f2686497d6eae8">read_coils_cb</a> (<a class="el" href="struct_session.html">Session</a> *session, uint16_t start, uint16_t count, void(*callback)(<a class="el" href="struct_result.html">Result</a>, <a class="el" href="rodbus_8h.html#ab53c4c86b8df187b3535456771fa8681">BitIterator</a> *, void *), void *user_data)</td></tr>
<tr class="memdesc:a9cd307d999611d65b5f2686497d6eae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform a non-blocking operation to read coils  <a href="#a9cd307d999611d65b5f2686497d6eae8">More...</a><br /></td></tr>
<tr class="separator:a9cd307d999611d65b5f2686497d6eae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42687e7ef453700b1f8160e8e5da715"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#ad42687e7ef453700b1f8160e8e5da715">read_discrete_inputs</a> (<a class="el" href="struct_session.html">Session</a> *session, uint16_t start, uint16_t count, bool *output)</td></tr>
<tr class="memdesc:ad42687e7ef453700b1f8160e8e5da715"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform a blocking operation to read discrete inputs  <a href="#ad42687e7ef453700b1f8160e8e5da715">More...</a><br /></td></tr>
<tr class="separator:ad42687e7ef453700b1f8160e8e5da715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1876b80071bc7902d2d86524c0abb6ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#a1876b80071bc7902d2d86524c0abb6ca">read_discrete_inputs_cb</a> (<a class="el" href="struct_session.html">Session</a> *session, uint16_t start, uint16_t count, void(*callback)(<a class="el" href="struct_result.html">Result</a>, <a class="el" href="rodbus_8h.html#ab53c4c86b8df187b3535456771fa8681">BitIterator</a> *, void *), void *user_data)</td></tr>
<tr class="memdesc:a1876b80071bc7902d2d86524c0abb6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform a non-blocking operation to read discrete inputs  <a href="#a1876b80071bc7902d2d86524c0abb6ca">More...</a><br /></td></tr>
<tr class="separator:a1876b80071bc7902d2d86524c0abb6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd934150a7b2bb07bac2c61112af5849"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#afd934150a7b2bb07bac2c61112af5849">read_holding_registers</a> (<a class="el" href="struct_session.html">Session</a> *session, uint16_t start, uint16_t count, uint16_t *output)</td></tr>
<tr class="memdesc:afd934150a7b2bb07bac2c61112af5849"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform a blocking operation to read holding registers  <a href="#afd934150a7b2bb07bac2c61112af5849">More...</a><br /></td></tr>
<tr class="separator:afd934150a7b2bb07bac2c61112af5849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3538834f113b232e5d5c857cb1d00e6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#a3538834f113b232e5d5c857cb1d00e6c">read_holding_registers_cb</a> (<a class="el" href="struct_session.html">Session</a> *session, uint16_t start, uint16_t count, void(*callback)(<a class="el" href="struct_result.html">Result</a>, <a class="el" href="rodbus_8h.html#a1479d7a4be4e0a3ed7c0656724dc1dd0">RegisterIterator</a> *, void *), void *user_data)</td></tr>
<tr class="memdesc:a3538834f113b232e5d5c857cb1d00e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform a non-blocking operation to read holding registers  <a href="#a3538834f113b232e5d5c857cb1d00e6c">More...</a><br /></td></tr>
<tr class="separator:a3538834f113b232e5d5c857cb1d00e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55eb307453cc992b2806faa9bcd944e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#aa55eb307453cc992b2806faa9bcd944e">read_input_registers</a> (<a class="el" href="struct_session.html">Session</a> *session, uint16_t start, uint16_t count, uint16_t *output)</td></tr>
<tr class="memdesc:aa55eb307453cc992b2806faa9bcd944e"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform a blocking operation to read input registers  <a href="#aa55eb307453cc992b2806faa9bcd944e">More...</a><br /></td></tr>
<tr class="separator:aa55eb307453cc992b2806faa9bcd944e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe98413a265f083e44c807adb3e77e97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#afe98413a265f083e44c807adb3e77e97">read_input_registers_cb</a> (<a class="el" href="struct_session.html">Session</a> *session, uint16_t start, uint16_t count, void(*callback)(<a class="el" href="struct_result.html">Result</a>, <a class="el" href="rodbus_8h.html#a1479d7a4be4e0a3ed7c0656724dc1dd0">RegisterIterator</a> *, void *), void *user_data)</td></tr>
<tr class="memdesc:afe98413a265f083e44c807adb3e77e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform a non-blocking operation to read input registers  <a href="#afe98413a265f083e44c807adb3e77e97">More...</a><br /></td></tr>
<tr class="separator:afe98413a265f083e44c807adb3e77e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ddc031e0c4afc244666f0b60940c8c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#a1ddc031e0c4afc244666f0b60940c8c0">release_updater</a> (<a class="el" href="rodbus_8h.html#a993c841f36546f091efb45eb10bdeb65">Updater</a> *updater)</td></tr>
<tr class="separator:a1ddc031e0c4afc244666f0b60940c8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff217ee71ce2c9bf91632d0d20ae2946"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#aff217ee71ce2c9bf91632d0d20ae2946">set_log_callback</a> (void(*callback)(<a class="el" href="rodbus_8h.html#a221b779e6bb7b8d40677d7642bfefac5">Level</a> level, const char *message))</td></tr>
<tr class="memdesc:aff217ee71ce2c9bf91632d0d20ae2946"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the callback to invoke when an enabled level is logged  <a href="#aff217ee71ce2c9bf91632d0d20ae2946">More...</a><br /></td></tr>
<tr class="separator:aff217ee71ce2c9bf91632d0d20ae2946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05981f1ce26c086993a77fd70eec230"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#ab05981f1ce26c086993a77fd70eec230">set_max_level</a> (<a class="el" href="rodbus_8h.html#a221b779e6bb7b8d40677d7642bfefac5">Level</a> level)</td></tr>
<tr class="memdesc:ab05981f1ce26c086993a77fd70eec230"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the maximum log level  <a href="#ab05981f1ce26c086993a77fd70eec230">More...</a><br /></td></tr>
<tr class="separator:ab05981f1ce26c086993a77fd70eec230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b26e9a50ae594fdda800c97d77ec01"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#ab1b26e9a50ae594fdda800c97d77ec01">update_coil</a> (<a class="el" href="rodbus_8h.html#a993c841f36546f091efb45eb10bdeb65">Updater</a> *updater, bool value, uint16_t index)</td></tr>
<tr class="separator:ab1b26e9a50ae594fdda800c97d77ec01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6be375f7f5f2f62923f0c931de5b241"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#ac6be375f7f5f2f62923f0c931de5b241">update_handler</a> (<a class="el" href="rodbus_8h.html#a7e7f3245e13691d73f52c0b7caf580f3">Handler</a> *handler, void *user_data, void(*callback)(<a class="el" href="rodbus_8h.html#a993c841f36546f091efb45eb10bdeb65">Updater</a> *, void *))</td></tr>
<tr class="separator:ac6be375f7f5f2f62923f0c931de5b241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c2d33bb4ff5d66ec8b0337a8260818"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#a04c2d33bb4ff5d66ec8b0337a8260818">write_multiple_coils</a> (<a class="el" href="struct_session.html">Session</a> *session, uint16_t start, const bool *values, uint16_t count)</td></tr>
<tr class="memdesc:a04c2d33bb4ff5d66ec8b0337a8260818"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform a blocking operation to write multiple coils  <a href="#a04c2d33bb4ff5d66ec8b0337a8260818">More...</a><br /></td></tr>
<tr class="separator:a04c2d33bb4ff5d66ec8b0337a8260818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac112038de205e26574c59277973dc9ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#ac112038de205e26574c59277973dc9ac">write_multiple_coils_cb</a> (<a class="el" href="struct_session.html">Session</a> *session, uint16_t start, const bool *values, uint16_t count, void(*callback)(<a class="el" href="struct_result.html">Result</a>, void *), void *user_data)</td></tr>
<tr class="memdesc:ac112038de205e26574c59277973dc9ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform a non-blocking operation to write multiple coils  <a href="#ac112038de205e26574c59277973dc9ac">More...</a><br /></td></tr>
<tr class="separator:ac112038de205e26574c59277973dc9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e8cfee194af77cd6c43257feb5ed5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#a37e8cfee194af77cd6c43257feb5ed5a">write_multiple_registers</a> (<a class="el" href="struct_session.html">Session</a> *session, uint16_t start, const uint16_t *values, uint16_t count)</td></tr>
<tr class="memdesc:a37e8cfee194af77cd6c43257feb5ed5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform a blocking operation to write multiple registers  <a href="#a37e8cfee194af77cd6c43257feb5ed5a">More...</a><br /></td></tr>
<tr class="separator:a37e8cfee194af77cd6c43257feb5ed5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81fcfe6fb38b10a6bc67d260ce4d731"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#ab81fcfe6fb38b10a6bc67d260ce4d731">write_multiple_registers_cb</a> (<a class="el" href="struct_session.html">Session</a> *session, uint16_t start, const uint16_t *values, uint16_t count, void(*callback)(<a class="el" href="struct_result.html">Result</a>, void *), void *user_data)</td></tr>
<tr class="memdesc:ab81fcfe6fb38b10a6bc67d260ce4d731"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform a non-blocking operation to write multiple registers  <a href="#ab81fcfe6fb38b10a6bc67d260ce4d731">More...</a><br /></td></tr>
<tr class="separator:ab81fcfe6fb38b10a6bc67d260ce4d731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf01a7f6fdd1ea9ccd6bb1369fca502c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#aaf01a7f6fdd1ea9ccd6bb1369fca502c">write_single_coil</a> (<a class="el" href="struct_session.html">Session</a> *session, uint16_t index, bool value)</td></tr>
<tr class="memdesc:aaf01a7f6fdd1ea9ccd6bb1369fca502c"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform a blocking operation to write a single coil  <a href="#aaf01a7f6fdd1ea9ccd6bb1369fca502c">More...</a><br /></td></tr>
<tr class="separator:aaf01a7f6fdd1ea9ccd6bb1369fca502c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327ccccc822f94fa942bb7ef3d78f042"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#a327ccccc822f94fa942bb7ef3d78f042">write_single_coil_cb</a> (<a class="el" href="struct_session.html">Session</a> *session, uint16_t index, bool value, void(*callback)(<a class="el" href="struct_result.html">Result</a>, void *), void *user_data)</td></tr>
<tr class="memdesc:a327ccccc822f94fa942bb7ef3d78f042"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform a non-blocking operation to write a single coil  <a href="#a327ccccc822f94fa942bb7ef3d78f042">More...</a><br /></td></tr>
<tr class="separator:a327ccccc822f94fa942bb7ef3d78f042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2771c4afc8508f8d54054dea698c4707"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#a2771c4afc8508f8d54054dea698c4707">write_single_register</a> (<a class="el" href="struct_session.html">Session</a> *session, uint16_t index, uint16_t value)</td></tr>
<tr class="memdesc:a2771c4afc8508f8d54054dea698c4707"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform a blocking operation to write a single register  <a href="#a2771c4afc8508f8d54054dea698c4707">More...</a><br /></td></tr>
<tr class="separator:a2771c4afc8508f8d54054dea698c4707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4259f83622e0fda71a38d834126cfe16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rodbus_8h.html#a4259f83622e0fda71a38d834126cfe16">write_single_register_cb</a> (<a class="el" href="struct_session.html">Session</a> *session, uint16_t index, uint16_t value, void(*callback)(<a class="el" href="struct_result.html">Result</a>, void *), void *user_data)</td></tr>
<tr class="memdesc:a4259f83622e0fda71a38d834126cfe16"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform a non-blocking operation to write a single register  <a href="#a4259f83622e0fda71a38d834126cfe16">More...</a><br /></td></tr>
<tr class="separator:a4259f83622e0fda71a38d834126cfe16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a33cd4def3f49e5c51e0c17184e3f4f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33cd4def3f49e5c51e0c17184e3f4f2c">&#9670;&nbsp;</a></span>MAX_READ_COILS_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_READ_COILS_COUNT&#160;&#160;&#160;2000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum count allowed in a read coils/discrete inputs request </p>

</div>
</div>
<a id="af6716f776ec018d9e18ba0d28ae104ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6716f776ec018d9e18ba0d28ae104ac">&#9670;&nbsp;</a></span>MAX_READ_REGISTERS_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_READ_REGISTERS_COUNT&#160;&#160;&#160;125</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum count allowed in a read holding/input registers request </p>

</div>
</div>
<a id="ae7bc9595980455fd0d58359d8cd97fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7bc9595980455fd0d58359d8cd97fb3">&#9670;&nbsp;</a></span>MAX_WRITE_COILS_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_WRITE_COILS_COUNT&#160;&#160;&#160;1968</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum count allowed in a <code>write multiple coils</code> request </p>

</div>
</div>
<a id="a5512749e704891158f2941eb0ecf1b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5512749e704891158f2941eb0ecf1b1e">&#9670;&nbsp;</a></span>MAX_WRITE_REGISTERS_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_WRITE_REGISTERS_COUNT&#160;&#160;&#160;123</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum count allowed in a <code>write multiple registers</code> request </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ab53c4c86b8df187b3535456771fa8681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab53c4c86b8df187b3535456771fa8681">&#9670;&nbsp;</a></span>BitIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="rodbus_8h.html#ab53c4c86b8df187b3535456771fa8681">BitIterator</a> <a class="el" href="rodbus_8h.html#ab53c4c86b8df187b3535456771fa8681">BitIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6776934484c8b4f38d405e630af94738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6776934484c8b4f38d405e630af94738">&#9670;&nbsp;</a></span>Callbacks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_callbacks.html">Callbacks</a>  <a class="el" href="struct_callbacks.html">Callbacks</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adac335ec9f22fdaa8e18ca2d8130d90a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac335ec9f22fdaa8e18ca2d8130d90a">&#9670;&nbsp;</a></span>Exception</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint8_t <a class="el" href="rodbus_8h.html#a8852f03cd91327c7c725673317d85b46">Exception</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e7f3245e13691d73f52c0b7caf580f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e7f3245e13691d73f52c0b7caf580f3">&#9670;&nbsp;</a></span>Handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="rodbus_8h.html#a7e7f3245e13691d73f52c0b7caf580f3">Handler</a> <a class="el" href="rodbus_8h.html#a7e7f3245e13691d73f52c0b7caf580f3">Handler</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a108f283de9b3b197e8cf1f6b2646c12c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108f283de9b3b197e8cf1f6b2646c12c">&#9670;&nbsp;</a></span>Level</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint8_t <a class="el" href="rodbus_8h.html#a221b779e6bb7b8d40677d7642bfefac5">Level</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1479d7a4be4e0a3ed7c0656724dc1dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1479d7a4be4e0a3ed7c0656724dc1dd0">&#9670;&nbsp;</a></span>RegisterIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="rodbus_8h.html#a1479d7a4be4e0a3ed7c0656724dc1dd0">RegisterIterator</a> <a class="el" href="rodbus_8h.html#a1479d7a4be4e0a3ed7c0656724dc1dd0">RegisterIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae49525aea41578e35d3e8fa40032fff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae49525aea41578e35d3e8fa40032fff9">&#9670;&nbsp;</a></span>Result</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_result.html">Result</a>  <a class="el" href="struct_result.html">Result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type that describes the success or failure of an operation. </p>

</div>
</div>
<a id="a313c85f25e6379ee8b06fd7af42e5f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313c85f25e6379ee8b06fd7af42e5f26">&#9670;&nbsp;</a></span>RuntimeConfig</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_runtime_config.html">RuntimeConfig</a>  <a class="el" href="struct_runtime_config.html">RuntimeConfig</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optional non-default configuration of the Tokio runtime. </p>

</div>
</div>
<a id="a2a4d68429aebf64b1a0686d32a333787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a4d68429aebf64b1a0686d32a333787">&#9670;&nbsp;</a></span>ServerHandle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="rodbus_8h.html#a2a4d68429aebf64b1a0686d32a333787">ServerHandle</a> <a class="el" href="rodbus_8h.html#a2a4d68429aebf64b1a0686d32a333787">ServerHandle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f1b89c3102156804ef750df9ac42d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f1b89c3102156804ef750df9ac42d97">&#9670;&nbsp;</a></span>Session</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_session.html">Session</a>  <a class="el" href="struct_session.html">Session</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Struct that bundles together the types needed to make requests on a channel. </p>

</div>
</div>
<a id="afc210d6f5ce14c41ad562ef100ac3532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc210d6f5ce14c41ad562ef100ac3532">&#9670;&nbsp;</a></span>Sizes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_sizes.html">Sizes</a>  <a class="el" href="struct_sizes.html">Sizes</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af4f792ad9fd33e21293f4305ac9951cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f792ad9fd33e21293f4305ac9951cb">&#9670;&nbsp;</a></span>Status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint8_t <a class="el" href="rodbus_8h.html#a67a0db04d321a74b7e7fcfd3f1a3f70b">Status</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a993c841f36546f091efb45eb10bdeb65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a993c841f36546f091efb45eb10bdeb65">&#9670;&nbsp;</a></span>Updater</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="rodbus_8h.html#a993c841f36546f091efb45eb10bdeb65">Updater</a> <a class="el" href="rodbus_8h.html#a993c841f36546f091efb45eb10bdeb65">Updater</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f667aaa4f41c199aa8f5d54fa7abbdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f667aaa4f41c199aa8f5d54fa7abbdc">&#9670;&nbsp;</a></span>WriteMultipleCallback_bool</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* WriteMultipleCallback_bool) (const bool *, uint16_t, uint16_t, void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb591b5372fb9faaab1a4648568fcdb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb591b5372fb9faaab1a4648568fcdb0">&#9670;&nbsp;</a></span>WriteMultipleCallback_u16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* WriteMultipleCallback_u16) (const uint16_t *, uint16_t, uint16_t, void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad039b46d64231cd22a98d29d400cef6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad039b46d64231cd22a98d29d400cef6c">&#9670;&nbsp;</a></span>WriteSingleCallback_bool</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* WriteSingleCallback_bool) (bool, uint16_t, void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa75ccc37e5e9e41478938d3391afe192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75ccc37e5e9e41478938d3391afe192">&#9670;&nbsp;</a></span>WriteSingleCallback_u16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* WriteSingleCallback_u16) (uint16_t, uint16_t, void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a8852f03cd91327c7c725673317d85b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8852f03cd91327c7c725673317d85b46">&#9670;&nbsp;</a></span>Exception</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rodbus_8h.html#a8852f03cd91327c7c725673317d85b46">Exception</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception values from the Modbus specification </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8852f03cd91327c7c725673317d85b46a8a4915a2a34c1ab34d038ea97fa7b709"></a>EXCEPTION_ILLEGAL_FUNCTION&#160;</td><td class="fielddoc"><p>The function code received in the query is not an allowable action for the server </p>
</td></tr>
<tr><td class="fieldname"><a id="a8852f03cd91327c7c725673317d85b46a7b0b398e7376a97021809dee5787fe8d"></a>EXCEPTION_ILLEGAL_DATA_ADDRESS&#160;</td><td class="fielddoc"><p>The data address received in the query is not an allowable address for the server </p>
</td></tr>
<tr><td class="fieldname"><a id="a8852f03cd91327c7c725673317d85b46a5ebe78681cfc53531dc576e386ea99c6"></a>EXCEPTION_ILLEGAL_DATA_VALUE&#160;</td><td class="fielddoc"><p>A value contained in the request is not an allowable value for server </p>
</td></tr>
<tr><td class="fieldname"><a id="a8852f03cd91327c7c725673317d85b46a99262768ea68576a7393e449a85877a5"></a>EXCEPTION_SERVER_DEVICE_FAILURE&#160;</td><td class="fielddoc"><p>An unrecoverable error occurred while the server was attempting to perform the requested action </p>
</td></tr>
<tr><td class="fieldname"><a id="a8852f03cd91327c7c725673317d85b46a4615b0ea86a36267ae531f78a6b052de"></a>EXCEPTION_ACKNOWLEDGE&#160;</td><td class="fielddoc"><p>Specialized use in conjunction with programming commands The server has accepted the request and is processing it </p>
</td></tr>
<tr><td class="fieldname"><a id="a8852f03cd91327c7c725673317d85b46ad796a97a298b53b63908bde5180b695a"></a>EXCEPTION_SERVER_DEVICE_BUSY&#160;</td><td class="fielddoc"><p>Specialized use in conjunction with programming commands The server is engaged in processing a long-duration program command, try again later </p>
</td></tr>
<tr><td class="fieldname"><a id="a8852f03cd91327c7c725673317d85b46ac5ebf2927bd32cc02fdfc59dbc8b6933"></a>EXCEPTION_MEMORY_PARITY_ERROR&#160;</td><td class="fielddoc"><p>Specialized use in conjunction with function codes 20 and 21 and reference type 6, to indicate that the extended file area failed to pass a consistency check. The server attempted to read a record file, but detected a parity error in the memory </p>
</td></tr>
<tr><td class="fieldname"><a id="a8852f03cd91327c7c725673317d85b46aed20382ced082cb1dcdcc845f1e82f10"></a>EXCEPTION_GATEWAY_PATH_UNAVAILABLE&#160;</td><td class="fielddoc"><p>Specialized use in conjunction with gateways, indicates that the gateway was unable to allocate an internal communication path from the input port to the output port for processing the request. Usually means that the gateway is mis-configured or overloaded </p>
</td></tr>
<tr><td class="fieldname"><a id="a8852f03cd91327c7c725673317d85b46a7e683d36801355c4979556ac0c1b856f"></a>EXCEPTION_GATEWAY_TARGET_DEVICE_FAILED_TO_RESPOND&#160;</td><td class="fielddoc"><p>Specialized use in conjunction with gateways, indicates that no response was obtained from the target device. Usually means that the device is not present on the network. </p>
</td></tr>
</table>

</div>
</div>
<a id="a221b779e6bb7b8d40677d7642bfefac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a221b779e6bb7b8d40677d7642bfefac5">&#9670;&nbsp;</a></span>Level</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rodbus_8h.html#a221b779e6bb7b8d40677d7642bfefac5">Level</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Levels of logging </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a221b779e6bb7b8d40677d7642bfefac5a56f6226774ca281a80cd2ee0ddd84f8b"></a>LEVEL_ERROR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a221b779e6bb7b8d40677d7642bfefac5af1af3c11f22a52b3c8e7b2472275181f"></a>LEVEL_WARN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a221b779e6bb7b8d40677d7642bfefac5a831e8f5cdb3ed97330b2e17502149d8f"></a>LEVEL_INFO&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a221b779e6bb7b8d40677d7642bfefac5a210bac66f34a56114215d54588b8c7f3"></a>LEVEL_DEBUG&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a221b779e6bb7b8d40677d7642bfefac5a1ca076c143f2ec60ba02c86573af9da3"></a>LEVEL_TRACE&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a67a0db04d321a74b7e7fcfd3f1a3f70b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67a0db04d321a74b7e7fcfd3f1a3f70b">&#9670;&nbsp;</a></span>Status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rodbus_8h.html#a67a0db04d321a74b7e7fcfd3f1a3f70b">Status</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Status returned during synchronous and asynchronous API calls </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a67a0db04d321a74b7e7fcfd3f1a3f70ba7e4a42e3b6dd63708c64cf3db6f69566"></a>STATUS_OK&#160;</td><td class="fielddoc"><p>The operation was successful and any return value may be used </p>
</td></tr>
<tr><td class="fieldname"><a id="a67a0db04d321a74b7e7fcfd3f1a3f70bafe3be2ba8f0a700faab0406f0343865b"></a>STATUS_SHUTDOWN&#160;</td><td class="fielddoc"><p>The channel was shutdown before the operation could complete </p>
</td></tr>
<tr><td class="fieldname"><a id="a67a0db04d321a74b7e7fcfd3f1a3f70bab08ccce70f99d316ca27d1b008d42226"></a>STATUS_NO_CONNECTION&#160;</td><td class="fielddoc"><p>No connection could be made to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="a67a0db04d321a74b7e7fcfd3f1a3f70badf018f95e71f6974db3f5c46ca93cb23"></a>STATUS_RESPONSE_TIMEOUT&#160;</td><td class="fielddoc"><p>No valid response was received before the timeout </p>
</td></tr>
<tr><td class="fieldname"><a id="a67a0db04d321a74b7e7fcfd3f1a3f70ba43c6fc585ae12703b11c0bc9ea7c0f2b"></a>STATUS_BAD_REQUEST&#160;</td><td class="fielddoc"><p>The request was invalid </p>
</td></tr>
<tr><td class="fieldname"><a id="a67a0db04d321a74b7e7fcfd3f1a3f70ba4b03b4e872682fcc47146c62e0f4d4ee"></a>STATUS_BAD_RESPONSE&#160;</td><td class="fielddoc"><p>The response was improperly formatted </p>
</td></tr>
<tr><td class="fieldname"><a id="a67a0db04d321a74b7e7fcfd3f1a3f70ba6373919fa18245967d76144389ca22fd"></a>STATUS_IO_ERROR&#160;</td><td class="fielddoc"><p>An I/O error occurred on the underlying stream while performing the request </p>
</td></tr>
<tr><td class="fieldname"><a id="a67a0db04d321a74b7e7fcfd3f1a3f70ba00923b9e21c66ab1958fd8ebcbc56d86"></a>STATUS_BAD_FRAMING&#160;</td><td class="fielddoc"><p>A framing error was detected while performing the request </p>
</td></tr>
<tr><td class="fieldname"><a id="a67a0db04d321a74b7e7fcfd3f1a3f70ba376a5fd798c7c418fdf4a664e648f984"></a>STATUS_EXCEPTION&#160;</td><td class="fielddoc"><p>The server returned an exception code (see separate exception value) </p>
</td></tr>
<tr><td class="fieldname"><a id="a67a0db04d321a74b7e7fcfd3f1a3f70badbee399e52770145a726e8bf2a7d6c83"></a>STATUS_INTERNAL_ERROR&#160;</td><td class="fielddoc"><p>An unspecified internal error occurred while performing the request </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2bacd8d546939e77079400e4b4785ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bacd8d546939e77079400e4b4785ae4">&#9670;&nbsp;</a></span>acquire_updater()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rodbus_8h.html#a993c841f36546f091efb45eb10bdeb65">Updater</a>* acquire_updater </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rodbus_8h.html#a7e7f3245e13691d73f52c0b7caf580f3">Handler</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a12b2c41bbed5f0474ec818be8c207e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b2c41bbed5f0474ec818be8c207e60">&#9670;&nbsp;</a></span>build_session()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_session.html">Session</a> build_session </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="prelude_8h.html#a26be402b6358a7159963c58bfcd5819f">Runtime</a> *&#160;</td>
          <td class="paramname"><em>runtime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="prelude_8h.html#afba562878a3535479ef88914e89ee38b">Channel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>unit_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function to build a session struct. </p>
<p>This function does not allocate and is merely a helper function create the <a class="el" href="struct_session.html" title="Struct that bundles together the types needed to make requests on a channel. ">Session</a> struct.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">runtime</td><td>pointer to the <a class="el" href="prelude_8h.html#a26be402b6358a7159963c58bfcd5819f" title="Opaque pointer type for the Tokio runtime. ">Runtime</a> that will be used to make requests on the channel </td></tr>
    <tr><td class="paramname">channel</td><td>pointer to the <a class="el" href="prelude_8h.html#afba562878a3535479ef88914e89ee38b" title="Opaque pointer type for the Channel. ">Channel</a> on which requests associated with the built <a class="el" href="struct_session.html" title="Struct that bundles together the types needed to make requests on a channel. ">Session</a> will be made </td></tr>
    <tr><td class="paramname">unit_id</td><td>Modbus unit identifier of the server </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>timeout in milliseconds for any requests made via this session object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>built <a class="el" href="struct_session.html" title="Struct that bundles together the types needed to make requests on a channel. ">Session</a> struct ready for use with the Modbus request functions </dd></dl>

</div>
</div>
<a id="a4c5bf17a00e67b15e844462febb25065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c5bf17a00e67b15e844462febb25065">&#9670;&nbsp;</a></span>create_callbacks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_callbacks.html">Callbacks</a> create_callbacks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rodbus_8h.html#ad039b46d64231cd22a98d29d400cef6c">WriteSingleCallback_bool</a>&#160;</td>
          <td class="paramname"><em>write_single_coil_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rodbus_8h.html#aa75ccc37e5e9e41478938d3391afe192">WriteSingleCallback_u16</a>&#160;</td>
          <td class="paramname"><em>write_single_register_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rodbus_8h.html#a2f667aaa4f41c199aa8f5d54fa7abbdc">WriteMultipleCallback_bool</a>&#160;</td>
          <td class="paramname"><em>write_multiple_coils</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rodbus_8h.html#acb591b5372fb9faaab1a4648568fcdb0">WriteMultipleCallback_u16</a>&#160;</td>
          <td class="paramname"><em>write_multiple_registers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a591e5e747665b5920f2479ff7f6af910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591e5e747665b5920f2479ff7f6af910">&#9670;&nbsp;</a></span>create_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rodbus_8h.html#a7e7f3245e13691d73f52c0b7caf580f3">Handler</a>* create_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="prelude_8h.html#a26be402b6358a7159963c58bfcd5819f">Runtime</a> *&#160;</td>
          <td class="paramname"><em>runtime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_sizes.html">Sizes</a>&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_callbacks.html">Callbacks</a>&#160;</td>
          <td class="paramname"><em>callbacks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aea9f8ed2895405a6a928d19056bf4561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9f8ed2895405a6a928d19056bf4561">&#9670;&nbsp;</a></span>create_server()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rodbus_8h.html#a2a4d68429aebf64b1a0686d32a333787">ServerHandle</a>* create_server </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="prelude_8h.html#a26be402b6358a7159963c58bfcd5819f">Runtime</a> *&#160;</td>
          <td class="paramname"><em>runtime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>unit_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rodbus_8h.html#a7e7f3245e13691d73f52c0b7caf580f3">Handler</a> *&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0265406efea9cf22a481b867bcec06f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0265406efea9cf22a481b867bcec06f0">&#9670;&nbsp;</a></span>create_sizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_sizes.html">Sizes</a> create_sizes </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_coils</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_discrete_inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_holding_registers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_input_registers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abcb2c7bb90fd97a74cfd6d0572d3c3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcb2c7bb90fd97a74cfd6d0572d3c3ec">&#9670;&nbsp;</a></span>create_tcp_client()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="prelude_8h.html#afba562878a3535479ef88914e89ee38b">Channel</a>* create_tcp_client </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="prelude_8h.html#a26be402b6358a7159963c58bfcd5819f">Runtime</a> *&#160;</td>
          <td class="paramname"><em>runtime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_queued_requests</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an instance of a TCP client channel. </p>
<p>This function allocates an opaque struct which must be later destroyed using <a class="el" href="rodbus_8h.html#ad3ca2d2f2ed0ab11963dc54730105a7b" title="Destroy a previously created channel instance. ">destroy_channel()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">runtime</td><td>pointer to the <a class="el" href="prelude_8h.html#a26be402b6358a7159963c58bfcd5819f" title="Opaque pointer type for the Tokio runtime. ">Runtime</a> that will be used to run the channel task </td></tr>
    <tr><td class="paramname">address</td><td>string representation on an IPv4 or IPv6 address and port, e.g. "127.0.0.1:502" </td></tr>
    <tr><td class="paramname">max_queued_requests</td><td>Maximum number of queued requests that will be accepted before back-pressure (blocking) is applied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the channel or NULL if the address parameter cannot be parsed</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>destroying the underlying runtime does NOT automatically destroy a <a class="el" href="prelude_8h.html#afba562878a3535479ef88914e89ee38b" title="Opaque pointer type for the Channel. ">Channel</a> on the runtime and <a class="el" href="rodbus_8h.html#ad3ca2d2f2ed0ab11963dc54730105a7b" title="Destroy a previously created channel instance. ">destroy_channel()</a> must always be used to free the memory </dd></dl>

</div>
</div>
<a id="a5410132a1670efd88528088d9365952a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5410132a1670efd88528088d9365952a">&#9670;&nbsp;</a></span>create_threaded_runtime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="prelude_8h.html#a26be402b6358a7159963c58bfcd5819f">Runtime</a>* create_threaded_runtime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_runtime_config.html">RuntimeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create an instance of the multi-threaded work-stealing Tokio runtime </p>
<p>This instance is typically created at the beginning of your program and destroyed using <a class="el" href="rodbus_8h.html#ace9b66ac23c961204362dbe48598f7b4" title="Destroy a previously created runtime instance. ">destroy_runtime()</a> before your program exits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Optional configuration of the runtime. If "config" is NULL, default settings are applied</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An instance of the runtime or NULL if it cannot be created for some reason </dd></dl>

</div>
</div>
<a id="ad3ca2d2f2ed0ab11963dc54730105a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ca2d2f2ed0ab11963dc54730105a7b">&#9670;&nbsp;</a></span>destroy_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void destroy_channel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="prelude_8h.html#afba562878a3535479ef88914e89ee38b">Channel</a> *&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a previously created channel instance. </p>
<p>This operation stops channel task execution. Any pending asynchronous callbacks may not complete, and no further Modbus requests on this channel should be made after this call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td><a class="el" href="prelude_8h.html#afba562878a3535479ef88914e89ee38b" title="Opaque pointer type for the Channel. ">Channel</a> to stop and destroy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function checks for NULL and is a NOP in this case </dd></dl>

</div>
</div>
<a id="a200473b8beed8a70ff55a18b902834f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a200473b8beed8a70ff55a18b902834f0">&#9670;&nbsp;</a></span>destroy_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void destroy_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rodbus_8h.html#a7e7f3245e13691d73f52c0b7caf580f3">Handler</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace9b66ac23c961204362dbe48598f7b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9b66ac23c961204362dbe48598f7b4">&#9670;&nbsp;</a></span>destroy_runtime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void destroy_runtime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="prelude_8h.html#a26be402b6358a7159963c58bfcd5819f">Runtime</a> *&#160;</td>
          <td class="paramname"><em>runtime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a previously created runtime instance. </p>
<p>This operation is typically performed just before program exit. It blocks until the runtime stops and all operations are canceled. Any pending asynchronous callbacks may not complete, and no further Modbus requests can be made after this call using this runtime and any channels or sessions created from it</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">runtime</td><td><a class="el" href="prelude_8h.html#a26be402b6358a7159963c58bfcd5819f" title="Opaque pointer type for the Tokio runtime. ">Runtime</a> to stop and destroy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function checks for NULL and is a NOP in this case </dd></dl>

</div>
</div>
<a id="ad33724585794192d9866c988a1ea5835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33724585794192d9866c988a1ea5835">&#9670;&nbsp;</a></span>destroy_server()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void destroy_server </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rodbus_8h.html#a2a4d68429aebf64b1a0686d32a333787">ServerHandle</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a89467479f2356b5694d5294ea68ccdcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89467479f2356b5694d5294ea68ccdcf">&#9670;&nbsp;</a></span>get_next_bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool get_next_bit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rodbus_8h.html#ab53c4c86b8df187b3535456771fa8681">BitIterator</a> *&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>retrieve the next bit and/or index from iterator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointer</td><td>to the iterator </td></tr>
    <tr><td class="paramname">pointer</td><td>to the value to write (output param) </td></tr>
    <tr><td class="paramname">pointer</td><td>to the value to write (output param) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the iterator is non-null and it contained another value </dd></dl>

</div>
</div>
<a id="abcbc9b6b65ddad049cd64b4b7ec96a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcbc9b6b65ddad049cd64b4b7ec96a2f">&#9670;&nbsp;</a></span>get_next_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool get_next_register </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rodbus_8h.html#a1479d7a4be4e0a3ed7c0656724dc1dd0">RegisterIterator</a> *&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>retrieve the next register value and/or index from iterator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointer</td><td>to the iterator </td></tr>
    <tr><td class="paramname">pointer</td><td>to the value to write (output param) </td></tr>
    <tr><td class="paramname">pointer</td><td>to the value to write (output param) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the iterator is non-null and it contained another value </dd></dl>

</div>
</div>
<a id="ab85931f5288323e2dce1f7bf7c73b459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85931f5288323e2dce1f7bf7c73b459">&#9670;&nbsp;</a></span>read_coils()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_result.html">Result</a> read_coils </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_session.html">Session</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform a blocking operation to read coils </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>pointer to the <a class="el" href="struct_session.html" title="Struct that bundles together the types needed to make requests on a channel. ">Session</a> struct that provides the runtime, channel, etc </td></tr>
    <tr><td class="paramname">start</td><td>starting address for the operation </td></tr>
    <tr><td class="paramname">count</td><td>count of items for the operation </td></tr>
    <tr><td class="paramname">output</td><td>buffer that is written on success. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_result.html" title="Type that describes the success or failure of an operation. ">Result</a> struct describing the success or failure of the operation</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The output buffer must be at least as large as count, otherwise a buffer overrun will occur </dd></dl>

</div>
</div>
<a id="a9cd307d999611d65b5f2686497d6eae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cd307d999611d65b5f2686497d6eae8">&#9670;&nbsp;</a></span>read_coils_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void read_coils_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_session.html">Session</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="struct_result.html">Result</a>, <a class="el" href="rodbus_8h.html#ab53c4c86b8df187b3535456771fa8681">BitIterator</a> *, void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform a non-blocking operation to read coils </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>pointer to the <a class="el" href="struct_session.html" title="Struct that bundles together the types needed to make requests on a channel. ">Session</a> struct that provides the runtime, channel, etc </td></tr>
    <tr><td class="paramname">start</td><td>starting address for the operation </td></tr>
    <tr><td class="paramname">count</td><td>count of items for the operation </td></tr>
    <tr><td class="paramname">callback</td><td>callback function to invoke when the operation completes </td></tr>
    <tr><td class="paramname">user_data</td><td>pointer to optional user data providing context to the callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe </dd></dl>

</div>
</div>
<a id="ad42687e7ef453700b1f8160e8e5da715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad42687e7ef453700b1f8160e8e5da715">&#9670;&nbsp;</a></span>read_discrete_inputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_result.html">Result</a> read_discrete_inputs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_session.html">Session</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform a blocking operation to read discrete inputs </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>pointer to the <a class="el" href="struct_session.html" title="Struct that bundles together the types needed to make requests on a channel. ">Session</a> struct that provides the runtime, channel, etc </td></tr>
    <tr><td class="paramname">start</td><td>starting address for the operation </td></tr>
    <tr><td class="paramname">count</td><td>count of items for the operation </td></tr>
    <tr><td class="paramname">output</td><td>buffer that is written on success. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_result.html" title="Type that describes the success or failure of an operation. ">Result</a> struct describing the success or failure of the operation</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The output buffer must be at least as large as count, otherwise a buffer overrun will occur </dd></dl>

</div>
</div>
<a id="a1876b80071bc7902d2d86524c0abb6ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1876b80071bc7902d2d86524c0abb6ca">&#9670;&nbsp;</a></span>read_discrete_inputs_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void read_discrete_inputs_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_session.html">Session</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="struct_result.html">Result</a>, <a class="el" href="rodbus_8h.html#ab53c4c86b8df187b3535456771fa8681">BitIterator</a> *, void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform a non-blocking operation to read discrete inputs </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>pointer to the <a class="el" href="struct_session.html" title="Struct that bundles together the types needed to make requests on a channel. ">Session</a> struct that provides the runtime, channel, etc </td></tr>
    <tr><td class="paramname">start</td><td>starting address for the operation </td></tr>
    <tr><td class="paramname">count</td><td>count of items for the operation </td></tr>
    <tr><td class="paramname">callback</td><td>callback function to invoke when the operation completes </td></tr>
    <tr><td class="paramname">user_data</td><td>pointer to optional user data providing context to the callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe </dd></dl>

</div>
</div>
<a id="afd934150a7b2bb07bac2c61112af5849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd934150a7b2bb07bac2c61112af5849">&#9670;&nbsp;</a></span>read_holding_registers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_result.html">Result</a> read_holding_registers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_session.html">Session</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform a blocking operation to read holding registers </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>pointer to the <a class="el" href="struct_session.html" title="Struct that bundles together the types needed to make requests on a channel. ">Session</a> struct that provides the runtime, channel, etc </td></tr>
    <tr><td class="paramname">start</td><td>starting address for the operation </td></tr>
    <tr><td class="paramname">count</td><td>count of items for the operation </td></tr>
    <tr><td class="paramname">output</td><td>buffer that is written on success. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_result.html" title="Type that describes the success or failure of an operation. ">Result</a> struct describing the success or failure of the operation</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The output buffer must be at least as large as count, otherwise a buffer overrun will occur </dd></dl>

</div>
</div>
<a id="a3538834f113b232e5d5c857cb1d00e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3538834f113b232e5d5c857cb1d00e6c">&#9670;&nbsp;</a></span>read_holding_registers_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void read_holding_registers_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_session.html">Session</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="struct_result.html">Result</a>, <a class="el" href="rodbus_8h.html#a1479d7a4be4e0a3ed7c0656724dc1dd0">RegisterIterator</a> *, void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform a non-blocking operation to read holding registers </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>pointer to the <a class="el" href="struct_session.html" title="Struct that bundles together the types needed to make requests on a channel. ">Session</a> struct that provides the runtime, channel, etc </td></tr>
    <tr><td class="paramname">start</td><td>starting address for the operation </td></tr>
    <tr><td class="paramname">count</td><td>count of items for the operation </td></tr>
    <tr><td class="paramname">callback</td><td>callback function to invoke when the operation completes </td></tr>
    <tr><td class="paramname">user_data</td><td>pointer to optional user data providing context to the callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe </dd></dl>

</div>
</div>
<a id="aa55eb307453cc992b2806faa9bcd944e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55eb307453cc992b2806faa9bcd944e">&#9670;&nbsp;</a></span>read_input_registers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_result.html">Result</a> read_input_registers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_session.html">Session</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform a blocking operation to read input registers </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>pointer to the <a class="el" href="struct_session.html" title="Struct that bundles together the types needed to make requests on a channel. ">Session</a> struct that provides the runtime, channel, etc </td></tr>
    <tr><td class="paramname">start</td><td>starting address for the operation </td></tr>
    <tr><td class="paramname">count</td><td>count of items for the operation </td></tr>
    <tr><td class="paramname">output</td><td>buffer that is written on success. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_result.html" title="Type that describes the success or failure of an operation. ">Result</a> struct describing the success or failure of the operation</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The output buffer must be at least as large as count, otherwise a buffer overrun will occur </dd></dl>

</div>
</div>
<a id="afe98413a265f083e44c807adb3e77e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe98413a265f083e44c807adb3e77e97">&#9670;&nbsp;</a></span>read_input_registers_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void read_input_registers_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_session.html">Session</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="struct_result.html">Result</a>, <a class="el" href="rodbus_8h.html#a1479d7a4be4e0a3ed7c0656724dc1dd0">RegisterIterator</a> *, void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform a non-blocking operation to read input registers </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>pointer to the <a class="el" href="struct_session.html" title="Struct that bundles together the types needed to make requests on a channel. ">Session</a> struct that provides the runtime, channel, etc </td></tr>
    <tr><td class="paramname">start</td><td>starting address for the operation </td></tr>
    <tr><td class="paramname">count</td><td>count of items for the operation </td></tr>
    <tr><td class="paramname">callback</td><td>callback function to invoke when the operation completes </td></tr>
    <tr><td class="paramname">user_data</td><td>pointer to optional user data providing context to the callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe </dd></dl>

</div>
</div>
<a id="a1ddc031e0c4afc244666f0b60940c8c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ddc031e0c4afc244666f0b60940c8c0">&#9670;&nbsp;</a></span>release_updater()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void release_updater </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rodbus_8h.html#a993c841f36546f091efb45eb10bdeb65">Updater</a> *&#160;</td>
          <td class="paramname"><em>updater</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aff217ee71ce2c9bf91632d0d20ae2946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff217ee71ce2c9bf91632d0d20ae2946">&#9670;&nbsp;</a></span>set_log_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool set_log_callback </td>
          <td>(</td>
          <td class="paramtype">void(*)(<a class="el" href="rodbus_8h.html#a221b779e6bb7b8d40677d7642bfefac5">Level</a> level, const char *message)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the callback to invoke when an enabled level is logged </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Callback function to invoke</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the callback was successfully set </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this call will only succeed the first time it is made! </dd></dl>

</div>
</div>
<a id="ab05981f1ce26c086993a77fd70eec230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab05981f1ce26c086993a77fd70eec230">&#9670;&nbsp;</a></span>set_max_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_max_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rodbus_8h.html#a221b779e6bb7b8d40677d7642bfefac5">Level</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the maximum log level </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>maximum level at which messages will be logged </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1b26e9a50ae594fdda800c97d77ec01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1b26e9a50ae594fdda800c97d77ec01">&#9670;&nbsp;</a></span>update_coil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool update_coil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rodbus_8h.html#a993c841f36546f091efb45eb10bdeb65">Updater</a> *&#160;</td>
          <td class="paramname"><em>updater</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6be375f7f5f2f62923f0c931de5b241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6be375f7f5f2f62923f0c931de5b241">&#9670;&nbsp;</a></span>update_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void update_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rodbus_8h.html#a7e7f3245e13691d73f52c0b7caf580f3">Handler</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="rodbus_8h.html#a993c841f36546f091efb45eb10bdeb65">Updater</a> *, void *)&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04c2d33bb4ff5d66ec8b0337a8260818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c2d33bb4ff5d66ec8b0337a8260818">&#9670;&nbsp;</a></span>write_multiple_coils()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_result.html">Result</a> write_multiple_coils </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_session.html">Session</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform a blocking operation to write multiple coils </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>pointer to the <a class="el" href="struct_session.html" title="Struct that bundles together the types needed to make requests on a channel. ">Session</a> struct that provides the runtime, channel, etc </td></tr>
    <tr><td class="paramname">start</td><td>starting address of the values </td></tr>
    <tr><td class="paramname">values</td><td>array of values to write </td></tr>
    <tr><td class="paramname">count</td><td>of values to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_result.html" title="Type that describes the success or failure of an operation. ">Result</a> struct describing the success or failure of the operation</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The "values" array must contain at least "count" items or the function will read past the end of the buffer </dd></dl>

</div>
</div>
<a id="ac112038de205e26574c59277973dc9ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac112038de205e26574c59277973dc9ac">&#9670;&nbsp;</a></span>write_multiple_coils_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_multiple_coils_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_session.html">Session</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="struct_result.html">Result</a>, void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform a non-blocking operation to write multiple coils </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>pointer to the <a class="el" href="struct_session.html" title="Struct that bundles together the types needed to make requests on a channel. ">Session</a> struct that provides the runtime, channel, etc </td></tr>
    <tr><td class="paramname">start</td><td>starting address of the values </td></tr>
    <tr><td class="paramname">values</td><td>array of values to write </td></tr>
    <tr><td class="paramname">count</td><td>count of values to write </td></tr>
    <tr><td class="paramname">callback</td><td>callback function to invoke when the operation completes </td></tr>
    <tr><td class="paramname">user_data</td><td>pointer to optional user data data providing context to the callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>"values" must contain at least "count" items or the function will read past the end of the buffer </dd></dl>

</div>
</div>
<a id="a37e8cfee194af77cd6c43257feb5ed5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37e8cfee194af77cd6c43257feb5ed5a">&#9670;&nbsp;</a></span>write_multiple_registers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_result.html">Result</a> write_multiple_registers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_session.html">Session</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform a blocking operation to write multiple registers </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>pointer to the <a class="el" href="struct_session.html" title="Struct that bundles together the types needed to make requests on a channel. ">Session</a> struct that provides the runtime, channel, etc </td></tr>
    <tr><td class="paramname">start</td><td>starting address of the values </td></tr>
    <tr><td class="paramname">values</td><td>array of values to write </td></tr>
    <tr><td class="paramname">count</td><td>of values to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_result.html" title="Type that describes the success or failure of an operation. ">Result</a> struct describing the success or failure of the operation</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The "values" array must contain at least "count" items or the function will read past the end of the buffer </dd></dl>

</div>
</div>
<a id="ab81fcfe6fb38b10a6bc67d260ce4d731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab81fcfe6fb38b10a6bc67d260ce4d731">&#9670;&nbsp;</a></span>write_multiple_registers_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_multiple_registers_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_session.html">Session</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="struct_result.html">Result</a>, void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform a non-blocking operation to write multiple registers </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>pointer to the <a class="el" href="struct_session.html" title="Struct that bundles together the types needed to make requests on a channel. ">Session</a> struct that provides the runtime, channel, etc </td></tr>
    <tr><td class="paramname">start</td><td>starting address of the values </td></tr>
    <tr><td class="paramname">values</td><td>array of values to write </td></tr>
    <tr><td class="paramname">count</td><td>count of values to write </td></tr>
    <tr><td class="paramname">callback</td><td>callback function to invoke when the operation completes </td></tr>
    <tr><td class="paramname">user_data</td><td>pointer to optional user data data providing context to the callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>"values" must contain at least "count" items or the function will read past the end of the buffer </dd></dl>

</div>
</div>
<a id="aaf01a7f6fdd1ea9ccd6bb1369fca502c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf01a7f6fdd1ea9ccd6bb1369fca502c">&#9670;&nbsp;</a></span>write_single_coil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_result.html">Result</a> write_single_coil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_session.html">Session</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform a blocking operation to write a single coil </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>pointer to the <a class="el" href="struct_session.html" title="Struct that bundles together the types needed to make requests on a channel. ">Session</a> struct that provides the runtime, channel, etc </td></tr>
    <tr><td class="paramname">index</td><td>address of the value </td></tr>
    <tr><td class="paramname">value</td><td>value to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_result.html" title="Type that describes the success or failure of an operation. ">Result</a> struct describing the success or failure of the operation</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe </dd></dl>

</div>
</div>
<a id="a327ccccc822f94fa942bb7ef3d78f042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327ccccc822f94fa942bb7ef3d78f042">&#9670;&nbsp;</a></span>write_single_coil_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_single_coil_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_session.html">Session</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="struct_result.html">Result</a>, void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform a non-blocking operation to write a single coil </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>pointer to the <a class="el" href="struct_session.html" title="Struct that bundles together the types needed to make requests on a channel. ">Session</a> struct that provides the runtime, channel, etc </td></tr>
    <tr><td class="paramname">index</td><td>address of the value </td></tr>
    <tr><td class="paramname">value</td><td>value to write </td></tr>
    <tr><td class="paramname">callback</td><td>callback function to invoke when the operation completes </td></tr>
    <tr><td class="paramname">user_data</td><td>pointer to optional user data data providing context to the callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe </dd></dl>

</div>
</div>
<a id="a2771c4afc8508f8d54054dea698c4707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2771c4afc8508f8d54054dea698c4707">&#9670;&nbsp;</a></span>write_single_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_result.html">Result</a> write_single_register </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_session.html">Session</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform a blocking operation to write a single register </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>pointer to the <a class="el" href="struct_session.html" title="Struct that bundles together the types needed to make requests on a channel. ">Session</a> struct that provides the runtime, channel, etc </td></tr>
    <tr><td class="paramname">index</td><td>address of the value </td></tr>
    <tr><td class="paramname">value</td><td>value to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_result.html" title="Type that describes the success or failure of an operation. ">Result</a> struct describing the success or failure of the operation</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe </dd></dl>

</div>
</div>
<a id="a4259f83622e0fda71a38d834126cfe16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4259f83622e0fda71a38d834126cfe16">&#9670;&nbsp;</a></span>write_single_register_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_single_register_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_session.html">Session</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="struct_result.html">Result</a>, void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform a non-blocking operation to write a single register </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>pointer to the <a class="el" href="struct_session.html" title="Struct that bundles together the types needed to make requests on a channel. ">Session</a> struct that provides the runtime, channel, etc </td></tr>
    <tr><td class="paramname">index</td><td>address of the value </td></tr>
    <tr><td class="paramname">value</td><td>value to write </td></tr>
    <tr><td class="paramname">callback</td><td>callback function to invoke when the operation completes </td></tr>
    <tr><td class="paramname">user_data</td><td>pointer to optional user data data providing context to the callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
